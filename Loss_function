import numpy as np
from math import *
import matplotlib.cm as cm
from scipy.signal import convolve
import matplotlib.pyplot as plt
import matplotlib.animation as animation  # FuncAnimation()
import math
from PIL import Image, ImageDraw
from PIL import ImageFilter
from PIL import ImageColor
from pathlib import Path
import random
from matplotlib.patches import Ellipse
import cv2
from cv2 import VideoWriter, VideoWriter_fourcc, imread, resize
import glob
from skimage.util import random_noise

#=========================================================
#=========================================================
Functions
#=========================================================
#=========================================================

def S_lamb (x, lamb):
    if np.abs(x) <= lamb:
        return 0
    elif x> lamb:
        return x-lamb
    elif x<-lamb:
        return x+lamb
        
def proximal_mapping (X, lamb):
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            X[i][j]=S_lamb(X[i][j], lamb)

    return X
    
    
    def decomposition_cells (X, t, lamb_E, lamb_F, nb_cells):
    E = np.random.rand(nb_cells,X.shape[1])
    while np.linalg.norm(E) == 0:
         E = np.random.rand(nb_celss, X.shape[1])
    
    
    F =  np.random.rand(X.shape[0],nb_cells)
    while np.linalg.norm(F) == 0:
        F = np.random.rand(X.shape[0],nb_cells)

    F = F*255 
    
    for i in range(nb_cells):
        for j in range(X.shape[0]):
            n = F[j][i]
            if n>255/2:
                F[j][i] = 255
            else:
                F[j][i] =0
        
    
    i = 0
    E_old = np.zeros((E.shape[0],E.shape[1]))
    F_old = np.zeros((F.shape[0],F.shape[1]))
  
    while (np.linalg.norm(E) != 0 and np.linalg.norm(F) != 0) and np.linalg.norm(E-E_old,1)>t:# and np.linalg.norm(F-F_old,1)>t: # A CHANGER !!!!!
            #print(i,',', np.linalg.norm(D))
            E_old = E
            n_E = 1/(np.linalg.norm(F)**2)

            grad_E = np.dot(-F.T,X)+np.dot(np.dot(F.T,F),E)

            tot_E = E-n_E*grad_E
            E = proximal_mapping(tot_E, n_E*lamb_E)

            #
            F_old = F
            n_F = 1/(np.linalg.norm(E)**2)

            grad_F = np.dot(-X,E.T) + np.dot(np.dot(F,E),E.T)

            tot_F = F - n_F*grad_F
            F = proximal_mapping(tot_F, n_F*lamb_F)

            i= i +1
    #print(i)

    A = np.random.rand(nb_cells,X.shape[1])
    D = np.random.rand(X.shape[0],nb_cells)
    
    for i in range(nb_cells):
        for q in range(X.shape[1]):
            A[i][q] = E[i][q]*np.max(F[:,i])/255
            if A[i][q]<0: #suppose the signal only positive
                A[i][q]=0
        for j in range(X.shape[0]):
            n = F[j][i]/np.max(F[:,i])*255
            if n>255/2:
                D[j][i] = 255 #ceil(n)
            else: 
                D[j][i] = 0 #floor(n)
        
    
    return A, D
    
#=========================================================
#=========================================================
Test, we use here the signals and the image from the ground truth
#=========================================================
#=========================================================   

A_test = np.array([signal_1,signal_2,signal_3])


im_1_array = np.array(im_1) #transforme l'image en tableau
im_1_array = np.concatenate(im_1_array)


im_2_array = np.array(im_2) #transforme l'image en tableau
im_2_array = np.concatenate(im_2_array)

im_3_array = np.array(im_3) #transforme l'image en tableau
im_3_array = np.concatenate(im_3_array)

D_test = np.array([im_1_array.T,im_2_array.T,im_3_array.T]).T

print(A_test.shape)
print(D_test.shape)

X_test = np.dot(D_test,A_test)
X_test.shape

I,J = decomposition_cells(X_test, 0.01, 4.2,0.01,3)

q = 0
for i in range(J.shape[0]):
    for j in range(J.shape[1]):
        if J[i][j] != D_test[i][j]:
            #print('D=', J[i][j], ' vs Im=', D_test[i][j] )
            q = q +1
print(q,'fin')

sum(J != D_test)

for j in range(I.shape[0]):
    q=0
    for i in range(I.shape[1]):
        if round(I[j][i],1) != round(A_test[j][i],1):
            #print('A=', round(I[j][i],2), ' vs signal=', round(A_test[j][i],2) )
            q = q +1
    print(j,q)
#print(q, 'fin')
    
